**面试中让谈JVM**

**1**.**首先是JVM的内存模型**

​	JVM的内存模型主要分为两个区域：线程私有区域和线程共享区域

​	线程私有区域：

​		①程序计数器：是比较小的一块内存空间，可以看作是当前线程所执行的字节码的行号指示器，用于记录当前虚拟机正在执行的线程指令地址。

​		②虚拟机栈：每个方法执行的时候都会创建一个栈帧，用于存储局部变量表，操作数，动态连接，方法返回值等信息。当线程请求栈的深度超过虚拟机允许的最大深度时，会抛出StackOverFlowError

​		③本地方法栈：本地方法栈与虚拟机栈的作用差不多相同，区别是本地方法栈为虚拟机使用的native方法服务

​	线程共享区域：

​		①堆：几乎所有的对象实例和数组都要在堆上分配内存，因此该区域经常发生垃圾回收事件

​		②方法区：用于存放已被类加载的信息，常量，静态变量，即时编译后的代码等信息。在JDK1.8以后不存在方法区了，被元空间所取代，元空间被分为：运行时常量池，和类常量池。

**2**.**内存泄漏和内存溢出**

内存溢出：(out of memory)是指程序载申请内存空间时，没有足够的内存空间供其使用，出现out of memory，比如：申请了一个Integer大小的内存空间，但给它存了long才能存下的数，就是内存溢出

内存泄漏：(memory leak)是指程序在申请内存后，无法释放已申请的内存空间。一次内存泄漏危害可以忽略，但内存泄漏堆积后果很严重，

大量的内存泄漏会导致内存溢出

**3.如何判断一个对象是否存活**

​	①引用计数法

​		给每一个对象设置一个引用计数器，当有一个地方引用该对象时，引用计数器+1.引用失效时，引用计数器-1；当引用计数器为0时，就说明这个对象没有被引用，也就是垃圾对象，等待回收

​	②可达性分析法

​		从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用。

​		Java中可以作为GC Roots对象的有以下几种：

​			1. 虚拟机栈(栈帧中的本地变量表)中引用的对象

​			2. 方法区中类静态属性引用的对象

​			3. 方法区中常量引用的对象

​			4.本地方法栈中JNI(Native方法)引用的对象

**Java中的引用类型分为：**

​			**强引用**：强引用是我们使用最广泛的引用，如果一个对象具有强引用，那么垃圾回收期绝对不会回收它，当内存空间不足时，垃圾

回收器宁愿抛出OutOfMemoryError，也不会回收具有强引用的对象；

​			**弱引用**：无论当前内存空间是否充足，都会回收掉该对象

​			**软引用**：只有当内存不足时，才会回收它；

​			**虚引用**：它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一

个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器**回收时收到一个系统通知**；

​		

**4.垃圾回收算法**

​	①标记清除法（新生代算法）

​		标记：从GC roots 根集合进行扫描，对存活的对象进行标记

​		清除：然后对堆内存中未标记的对象清除

​		效率问题和空间碎片问题

​		（1）效率问题，标记和清除两个过程的效率都不高，

​		（2）空间问题，标记清除后会产生大量不连续的内存碎片

​	②标记整理法（新生代算法）

​		标记：从GC roots 根集合进行扫描，对存活的对象进行标记

​		整理：移动所有存活的对象，且按照内存地址次序依次排列将末端内存地址以后的内存全部回收

​	③复制算法（老年代算法）

​		将S0中存活的对象复制到S1中，再将S0中已使用过的内存空间一次处理掉这样使得每次都是对整个半区进行内存回收

​		内存使用率不高，只有50%

​	④分代收集算法（GC算法）

​		java堆 = 新生代+老年代；

​		新生代=Eden+Survivor（S0+S1），默认分配比例为：8：1：1

​		当Eden区满了的时候，就会触发一次Minior GC，来收集新生代的垃圾，存活下来的对象会被分配到Survivor区

​		大对象会直接被分配到老年代

​		如果对象在Eden区出生，并且经历了一次Minior GC之后依然存活，被分配到存活区的话，年龄+1；此后每经历一次Minior GC并且存活下来，年龄+1，当年龄到达15时，就会晋升到老年代

​		当老年代满了，无法容纳更多对象，会触发一次Full GC；Full GC存储的是整个内存堆（包括年轻代和老年代）

​		Major GC是发生在老年代的GC，清理老年区，经常会伴随至少一次minor gc；



**5.垃圾收集器**

CMS:
是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片；

G1:
标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选回收。不会产生空间碎片，可以精确地控制停顿；
G1将整个堆分为大小相等的多个Region（区域），G1跟踪每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，已达到在有限时间内获取尽可能高的回收效率；

**6.类加载的过程**

​	类的生命周期有7个阶段，类加载的5个步骤：

​	加载，验证，准备，解析，初始化

加载：

​	加载分为三步：
​	1、通过类的全限定性类名获取该类的二进制流；
​	2、将该二进制流的静态存储结构转为方法区的运行时数据结构；
​	3、在堆中为该类生成一个class对象；

验证：

​	验证该class文件中的字节流信息复合虚拟机的要求，不会威胁到jvm的安全；

准备：

​	为类变量分配内存，设置类变量的初始值；

解析：

​	该阶段主要完成符号引用转化成直接引用；**符号引用**就是一组符号来描述目标，可以是任何字面量；**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

初始化：

​	初始化是指**为类的静态变量赋予正确的初始值**

**7.双亲委派机制**

​	类加载器接收到类加载的请求，先调用父类加载器进行加载，每一次都是如此，一直找到启动类加载器，每一层无法加载时，让下层类加载器加载。