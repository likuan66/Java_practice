**1.深拷贝与浅拷贝**

​	简单点来说，就是假设B复制了A，当修改A时，看B是否发生变化，如果B也跟着变了，就是浅拷贝。如果B没有变就是深拷贝。

a.基本类型--名值存储在栈内存中，例如let a=1;

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/3477f9107730444a9457a9e354b8d37d/clipboard.png)

当你b=a复制时，栈内存会新开辟一个内存，例如这样：

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/8798d579244446b68c830a2d4f76ee22/clipboard.png)

所以当你此时修改a=2，对b并不会造成影响，当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。

s，

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/3fba353a8abe4b64ab2d86ddb4cece79/clipboard.png)

当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/4542888f67cc4ae8926489c1944f64f2/clipboard.png)

而当我们**a[0]=1**时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/7d6a6cd0ddd44255baa95139b2527654/clipboard.png)

那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，起步就达到深拷贝的效果了

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/58898ca075ac4b02918cd16056334f22/clipboard.png)

————————————————————————————————————————————

**2.topk**

全局排序  O(n*lg(n))：给所有的数都排序，然后取前K大或者前K小。

局部排序冒泡(n*k):首先第一种想法肯定是利用冒泡排序，求前K个数，只需要遍历K次即可。

堆排序(n*logk)：先构造一个大小为k的堆，求前k大的构建最小堆，（构建完之后，取新的元素，如果最小值小于当前的值，则覆盖然后调整一次堆）

快排(n*logn):首先选择一个标志位，如果这个标志位的序号index刚好是k，那么标志位和标志位左边的数，刚好就是top-k small data，如果index>k,那top-k small data在index的左边，那么就继续递归从index-1在数中选取top-k.如果index < k,那么说明还要从index的右边，选取top-(k-index) small data.

**3.双亲委派机制**

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/2cd1bbea47e94777bde417ea06e4b46b/clipboard.png)

1、如果一个类加载器收到类加载请求，它不会自己先加载，而是委托给父类的加载器去执行

2、如果父类加载器还存在父类加载器，则进一步委托，直到到达最顶层的类加载器

3、如果父类加载器可以完成类的加载任务，就成功返回，如果不能完成再回退到子类加载器判断

**作用：**

**1、避免类的重复加载**

比如A、B类都需要加载 String 类，如果不用委托而是自己加载自己的，则会在内存中生成两份字节码。

**2、保护程序安全，防止程序员随意修改JDK的类。**

**3.类的加载过程：加载——>验证——>准备——>解析——>初始化**

**反射**

**字节流和字符流的区别**

java流在处理上分为字符流和字节流，流中保存的实际上全都是字节文件 

①字符流（Writer/Reader）处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串。而字节流（OutputStream/InputStream）处理单元为1个字节，操作字节和字节数组。

②字节流可用于任何类型，而字符流只能处理字符或者字符串

③字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出。

​    字符流在操作的时候是使用到缓冲区的。如果字符流不调用close或flush方法，则不会输出任何内容。 

**hashcode和equals**

**HashMap**是基于散列函数，以数组和链表或者红黑树的方式实现的。

对于每一个对象，通过hashCode的方法可为气生成一个整形的值（散列码），改整形的值被处理后将作为数组的下标，存放该对象所对应的值。

equals()方法则是在HashMap中插入值或查询时会使用到，当HashMap中插入值或查询值对象的散列码与数组中对应的散列码相等时，则会通过equals方法比较key值是否相等，所以想以自建 对象作为HashMap的key，必须重写该对象继承的object、的equal、方法。

总结：

1.若重写了equals(Object obj)方法，则有必要重写hashCode()方法。

2.若两个对象equals(Object obj)返回true，则hashCode（）有必要也返回相同的int数。

3.若两个对象equals(Object obj)返回false，则hashCode（）不一定返回不同的int数。

4.若两个对象hashCode（）返回相同int数，则equals（Object obj）不一定返回true。

5.若两个对象hashCode（）返回不同int数，则equals（Object obj）一定返回false。

6.同一对象在执行期间若已经存储在集合中，则不能修改影响hashCode值的相关信息，否则会导致内存泄露问题。

**反射**

Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的方法和属性，对于任意一个对象，都能够调用它的任意的一个方法阿属性。这种动态获取的信息以及动态调用对象的方法称为反射。

**获取class的三种方式**

①对象 . getClass:getClass()方法在Object类中定义着

多用于对象获取字节码的方式

②类名 .class；通过类名的属性获取

多用于参数的传递

③Class . forName("全类名")：forName （String className）（常用）

多用于配置文件，将类名定义在配置文件中，读取文件，加载类

**反射优点和缺点**

优点：

①对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法

② 增加程序的灵活性和扩展性，降低耦合性，提高自适应能力

③反射已经运用在了很多流行框架如：Struts、Hibernate、Spring 等等。

缺点：

①我们认为反射是一个“自省”的过程，所以在性能上面有性能的问题，一般不建议用在小型程序上，可用到框架当中。

② 反射技术绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂 。

**事务**

https://blog.csdn.net/Stephen_curry_66/article/details/105987733

**索引**

https://blog.csdn.net/Stephen_curry_66/article/details/105967343

**session和cookie**

​	区别：1.cookie数据存放在客户浏览器上（客户端），session数据默认存放在服务器（服务端）的一个文件中（不是内存）

​				2.cookie不是很安全，别人可以分析存放在本地的cookie并进行欺骗，考虑安全的话使用session

​				3.session会在一定时间内保存在服务器上。当访问量增多时，会比较占用你服务器的性能，考虑到减轻服务器的性能，使用cookie

​				4.单个cookie保存的数据不能超过4k，很多浏览器限制一个站点最多保存20个cookie

​	联系：session的运行依赖session id，而session id 存放在cookie中，也就是说如果浏览器禁用了cookie，同时session同时也会失效（但是可以通过其他的方式实现，如在url中传递session id）。

​	应用场景：1.登录网站，今天输入用户名密码登录了，第二天再打开就直接可以打开了，这时候用到的就是cookie

​						2.session的一个场景是购物车，添加了商品之后客户端处知道添加了那些商品，而服务端如何判断呢，所以需要存储一些信息，就用到了session。

​			

**AQS**

​	AbstractQueuedSychronizer(抽象的队列式同步器)

​	核心思想：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源 设定为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入队列中。

​	CLH队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。

​	功能：独占和共享

​		独占锁，每次只能有一个线程持有锁，比如ReentrantLock就是以独占方式实现的互斥锁

​		共享锁，允许多个线程同时获取锁，并发访问共享资源，比如ReentrantReadWriteLock

**公平锁和非公平锁**

​	公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能获得锁

​	优点：所有的线程都能得到资源不会饿死在队列中。

​	缺点：吞吐量会下降很多，队列里面除了第一个线程，其他线程都会阻塞，cpu唤醒阻塞线程的开销会很大

​	非公平锁：多个线程获取锁的时候，会直接获取，如果获取不到再次进入等待队列，如果获取的到就直接获取到锁。

​	优点：可以减少CPU唤醒线程的开销，整体的吞吐量会增加，CPU也不必唤醒所有的线程，会减少换取线程的数量

​	缺点：这样有可能导致有的线程一直获取不到锁，而出现饿死。

**JDBC**

​	①加载数据库驱动到JVM

​		class.forName("JDBC驱动类的名称");

​	②建立数据库连接

​		Connection conn=DriverManager.getConnection(数据库url，数据库名，密码);

​	③获取数据库操作对象

​		Statement stmt=conn.createStatement();

​	④定义操作的SQL语句

​		String sql="写sql语句";

​	⑤执行数据库操作

​		ResultSet rs=stmt.executeQuery(sql);

​	⑥获取并操作结果集

​		while(rs.next()){

​			System.out.println(rs.getInt("id"));

​			System.out.println(rs.getString("name"));

​		}

​	⑦关闭对象，回收数据库资源（关闭结果集——>关闭数据库操作对象——>关闭连接）

​		最后在finally中关闭对象，rs.close();

​													 stmt.close();

​													 conn.close();

**单例模式**

​	1.懒汉式

​	https://img-blog.csdnimg.cn/20190623135131582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fic29sdXRlX2NoZW4=,size_16,color_FFFFFF,t_70

​	懒汉式，顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。有线程安全和线程不安全两种写法，区别就是synchronized关键字。

​	2.饿汉式

​	https://img-blog.csdnimg.cn/20190623135149892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fic29sdXRlX2NoZW4=,size_16,color_FFFFFF,t_70

​	饿汉式，从名字上也很好理解，就是“比较勤”，实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说。好处是没有线程安全的问题，坏处是浪费内存空间。

​	3.双重校验锁

​	https://img-blog.csdnimg.cn/20190623135205866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fic29sdXRlX2NoZW4=,size_16,color_FFFFFF,t_70

​	双检锁，又叫双重校验锁，综合了懒汉式和饿汉式两者的优缺点整合而成。看上面代码实现中，特点是在synchronized关键字内外都加了一层 if 条件判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。

​	4.静态类部类

​	https://img-blog.csdnimg.cn/20190623135218977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fic29sdXRlX2NoZW4=,size_16,color_FFFFFF,t_70

​	静态内部类的方式效果类似双检锁，但实现更简单。但这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。

​	5.枚举

​	https://img-blog.csdnimg.cn/20190623135234518.png

​	枚举的方式是比较少见的一种实现方式，但是看上面的代码实现，却更简洁清晰。并且她还自动支持序列化机制，绝对防止多次实例化。