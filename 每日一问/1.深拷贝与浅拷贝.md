**1.深拷贝与浅拷贝**

​	简单点来说，就是假设B复制了A，当修改A时，看B是否发生变化，如果B也跟着变了，就是浅拷贝。如果B没有变就是深拷贝。

a.基本类型--名值存储在栈内存中，例如let a=1;

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/3477f9107730444a9457a9e354b8d37d/clipboard.png)

当你b=a复制时，栈内存会新开辟一个内存，例如这样：

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/8798d579244446b68c830a2d4f76ee22/clipboard.png)

所以当你此时修改a=2，对b并不会造成影响，当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。

s，

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/3fba353a8abe4b64ab2d86ddb4cece79/clipboard.png)

当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/4542888f67cc4ae8926489c1944f64f2/clipboard.png)

而当我们**a[0]=1**时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/7d6a6cd0ddd44255baa95139b2527654/clipboard.png)

那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，起步就达到深拷贝的效果了

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/58898ca075ac4b02918cd16056334f22/clipboard.png)

————————————————————————————————————————————

**2.topk**

全局排序  O(n*lg(n))：给所有的数都排序，然后取前K大或者前K小。

局部排序冒泡(n*k):首先第一种想法肯定是利用冒泡排序，求前K个数，只需要遍历K次即可。

堆排序(n*logk)：先构造一个大小为k的堆，求前k大的构建最小堆，（构建完之后，取新的元素，如果最小值小于当前的值，则覆盖然后调整一次堆）

快排(n*logn):首先选择一个标志位，如果这个标志位的序号index刚好是k，那么标志位和标志位左边的数，刚好就是top-k small data，如果index>k,那top-k small data在index的左边，那么就继续递归从index-1在数中选取top-k.如果index < k,那么说明还要从index的右边，选取top-(k-index) small data.

**3.双亲委派机制**

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/2cd1bbea47e94777bde417ea06e4b46b/clipboard.png)

1、如果一个类加载器收到类加载请求，它不会自己先加载，而是委托给父类的加载器去执行

2、如果父类加载器还存在父类加载器，则进一步委托，直到到达最顶层的类加载器

3、如果父类加载器可以完成类的加载任务，就成功返回，如果不能完成再回退到子类加载器判断

**作用：**

**1、避免类的重复加载**

比如A、B类都需要加载 String 类，如果不用委托而是自己加载自己的，则会在内存中生成两份字节码。

**2、保护程序安全，防止程序员随意修改JDK的类。**

**3.类的加载过程：加载——>验证——>准备——>解析——>初始化**

**反射**

**字节流和字符流的区别**

java流在处理上分为字符流和字节流，流中保存的实际上全都是字节文件 

①字符流（Writer/Reader）处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串。而字节流（OutputStream/InputStream）处理单元为1个字节，操作字节和字节数组。

②字节流可用于任何类型，而字符流只能处理字符或者字符串

③字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出。

​    字符流在操作的时候是使用到缓冲区的。如果字符流不调用close或flush方法，则不会输出任何内容。 

**hashcode和equals**

**HashMap**是基于散列函数，以数组和链表或者红黑树的方式实现的。

对于每一个对象，通过hashCode的方法可为气生成一个整形的值（散列码），改整形的值被处理后将作为数组的下标，存放该对象所对应的值。

equals()方法则是在HashMap中插入值或查询时会使用到，当HashMap中插入值或查询值对象的散列码与数组中对应的散列码相等时，则会通过equals方法比较key值是否相等，所以想以自建 对象作为HashMap的key，必须重写该对象继承的object、的equal、方法。

总结：

1.若重写了equals(Object obj)方法，则有必要重写hashCode()方法。

2.若两个对象equals(Object obj)返回true，则hashCode（）有必要也返回相同的int数。

3.若两个对象equals(Object obj)返回false，则hashCode（）不一定返回不同的int数。

4.若两个对象hashCode（）返回相同int数，则equals（Object obj）不一定返回true。

5.若两个对象hashCode（）返回不同int数，则equals（Object obj）一定返回false。

6.同一对象在执行期间若已经存储在集合中，则不能修改影响hashCode值的相关信息，否则会导致内存泄露问题。

**反射**

Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的方法和属性，对于任意一个对象，都能够调用它的任意的一个方法阿属性。这种动态获取的信息以及动态调用对象的方法称为反射。

**获取class的三种方式**

①对象 . getClass:getClass()方法在Object类中定义着

多用于对象获取字节码的方式

②类名 .class；通过类名的属性获取

多用于参数的传递

③Class . forName("全类名")：forName （String className）（常用）

多用于配置文件，将类名定义在配置文件中，读取文件，加载类

**反射优点和缺点**

优点：

①对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法

② 增加程序的灵活性和扩展性，降低耦合性，提高自适应能力

③反射已经运用在了很多流行框架如：Struts、Hibernate、Spring 等等。

缺点：

①我们认为反射是一个“自省”的过程，所以在性能上面有性能的问题，一般不建议用在小型程序上，可用到框架当中。

② 反射技术绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂 。

**事务**

https://blog.csdn.net/Stephen_curry_66/article/details/105987733

**索引**

https://blog.csdn.net/Stephen_curry_66/article/details/105967343

**session和cookies**

**AQS**

**公平锁和非公平锁**

**JDBC**

**单例模式**