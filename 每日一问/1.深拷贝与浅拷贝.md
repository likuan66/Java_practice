**1.深拷贝与浅拷贝**

​	简单点来说，就是假设B复制了A，当修改A时，看B是否发生变化，如果B也跟着变了，就是浅拷贝。如果B没有变就是深拷贝。

a.基本类型--名值存储在栈内存中，例如let a=1;

https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124130901890-511917244.jpg

当你b=a复制时，栈内存会新开辟一个内存，例如这样：

https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124131822437-430949998.jpg

所以当你此时修改a=2，对b并不会造成影响，当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。

https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124133428359-1292133331.jpg

当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。

https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124133647796-1390255671.jpg

而当我们**a[0]=1**时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。

https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124133934328-67216865.jpg

那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，起步就达到深拷贝的效果了

https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124140906203-2099568933.jpg

————————————————————————————————————————————

**2.topk**

全局排序  O(n*lg(n))：给所有的数都排序，然后取前K大或者前K小。

局部排序冒泡(n*k):首先第一种想法肯定是利用冒泡排序，求前K个数，只需要遍历K次即可。

堆排序(n*logk)：先构造一个大小为k的堆，求前k大的构建最小堆，（构建完之后，取新的元素，如果最小值小于当前的值，则覆盖然后调整一次堆）

快排(n*logn):首先选择一个标志位，如果这个标志位的序号index刚好是k，那么标志位和标志位左边的数，刚好就是top-k small data，如果index>k,那top-k small data在index的左边，那么就继续递归从index-1在数中选取top-k.如果index < k,那么说明还要从index的右边，选取top-(k-index) small data.

----



**3.双亲委派机制**

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/2cd1bbea47e94777bde417ea06e4b46b/clipboard.png

1、如果一个类加载器收到类加载请求，它不会自己先加载，而是委托给父类的加载器去执行

2、如果父类加载器还存在父类加载器，则进一步委托，直到到达最顶层的类加载器

3、如果父类加载器可以完成类的加载任务，就成功返回，如果不能完成再回退到子类加载器判断

**作用：**

**1、避免类的重复加载**

比如A、B类都需要加载 String 类，如果不用委托而是自己加载自己的，则会在内存中生成两份字节码。

**2、保护程序安全，防止程序员随意修改JDK的类。**

**3.类的加载过程：加载——>验证——>准备——>解析——>初始化**



----



**字节流和字符流的区别**

java流在处理上分为字符流和字节流，流中保存的实际上全都是字节文件 

①字符流（Writer/Reader）处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串。而字节流（OutputStream/InputStream）处理单元为1个字节，操作字节和字节数组。

②字节流可用于任何类型，而字符流只能处理字符或者字符串

③字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出。

​    字符流在操作的时候是使用到缓冲区的。如果字符流不调用close或flush方法，则不会输出任何内容。 

----



**hashcode和equals**

**HashMap**是基于散列函数，以数组和链表或者红黑树的方式实现的。

对于每一个对象，通过hashCode的方法可为气生成一个整形的值（散列码），改整形的值被处理后将作为数组的下标，存放该对象所对应的值。

equals()方法则是在HashMap中插入值或查询时会使用到，当HashMap中插入值或查询值对象的散列码与数组中对应的散列码相等时，则会通过equals方法比较key值是否相等，所以想以自建 对象作为HashMap的key，必须重写该对象继承的object、的equal、方法。

总结：

1.若重写了equals(Object obj)方法，则有必要重写hashCode()方法。

2.若两个对象equals(Object obj)返回true，则hashCode（）有必要也返回相同的int数。

3.若两个对象equals(Object obj)返回false，则hashCode（）不一定返回不同的int数。

4.若两个对象hashCode（）返回相同int数，则equals（Object obj）不一定返回true。

5.若两个对象hashCode（）返回不同int数，则equals（Object obj）一定返回false。

6.同一对象在执行期间若已经存储在集合中，则不能修改影响hashCode值的相关信息，否则会导致内存泄露问题。

----



**反射**

Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的方法和属性，对于任意一个对象，都能够调用它的任意的一个方法阿属性。这种动态获取的信息以及动态调用对象的方法称为反射。

----



**获取class的三种方式**

①对象 . getClass:getClass()方法在Object类中定义着

多用于对象获取字节码的方式

②类名 .class；通过类名的属性获取

多用于参数的传递

③Class . forName("全类名")：forName （String className）（常用）

多用于配置文件，将类名定义在配置文件中，读取文件，加载类

----



**反射优点和缺点**

优点：

①对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法

② 增加程序的灵活性和扩展性，降低耦合性，提高自适应能力

③反射已经运用在了很多流行框架如：Struts、Hibernate、Spring 等等。

缺点：

①我们认为反射是一个“自省”的过程，所以在性能上面有性能的问题，一般不建议用在小型程序上，可用到框架当中。

② 反射技术绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂 。

----



**事务**

https://blog.csdn.net/Stephen_curry_66/article/details/105987733

----



**索引**

https://blog.csdn.net/Stephen_curry_66/article/details/105967343

----



**session和cookie**

​	区别：1.cookie数据存放在客户浏览器上（客户端），session数据默认存放在服务器（服务端）的一个文件中（不是内存）

​				2.cookie不是很安全，别人可以分析存放在本地的cookie并进行欺骗，考虑安全的话使用session

​				3.session会在一定时间内保存在服务器上。当访问量增多时，会比较占用你服务器的性能，考虑到减轻服务器的性能，使用cookie

​				4.单个cookie保存的数据不能超过4k，很多浏览器限制一个站点最多保存20个cookie

​	联系：session的运行依赖session id，而session id 存放在cookie中，也就是说如果浏览器禁用了cookie，同时session同时也会失效（但是可以通过其他的方式实现，如在url中传递session id）。

​	应用场景：1.登录网站，今天输入用户名密码登录了，第二天再打开就直接可以打开了，这时候用到的就是cookie

​						2.session的一个场景是购物车，添加了商品之后客户端处知道添加了那些商品，而服务端如何判断呢，所以需要存储一些信息，就用到了session。

----



**AQS**

​	AbstractQueuedSychronizer(抽象的队列式同步器)

​	核心思想：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源 设定为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入队列中。

​	CLH队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。

​	功能：独占和共享

​		独占锁，每次只能有一个线程持有锁，比如ReentrantLock就是以独占方式实现的互斥锁

​		共享锁，允许多个线程同时获取锁，并发访问共享资源，比如ReentrantReadWriteLock

----



**公平锁和非公平锁**

​	公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能获得锁

​	优点：所有的线程都能得到资源不会饿死在队列中。

​	缺点：吞吐量会下降很多，队列里面除了第一个线程，其他线程都会阻塞，cpu唤醒阻塞线程的开销会很大

​	非公平锁：多个线程获取锁的时候，会直接获取，如果获取不到再次进入等待队列，如果获取的到就直接获取到锁。

​	优点：可以减少CPU唤醒线程的开销，整体的吞吐量会增加，CPU也不必唤醒所有的线程，会减少换取线程的数量

​	缺点：这样有可能导致有的线程一直获取不到锁，而出现饿死。

----



**JDBC**

​	①加载数据库驱动到JVM

​		class.forName("JDBC驱动类的名称");

​	②建立数据库连接

​		Connection conn=DriverManager.getConnection(数据库url，数据库名，密码);

​	③获取数据库操作对象

​		Statement stmt=conn.createStatement();

​	④定义操作的SQL语句

​		String sql="写sql语句";

​	⑤执行数据库操作

​		ResultSet rs=stmt.executeQuery(sql);

​	⑥获取并操作结果集

​		while(rs.next()){

​			System.out.println(rs.getInt("id"));

​			System.out.println(rs.getString("name"));

​		}

​	⑦关闭对象，回收数据库资源（关闭结果集——>关闭数据库操作对象——>关闭连接）

​		最后在finally中关闭对象，rs.close();

​													 stmt.close();

​													 conn.close();

----



**单例模式**

​	1.懒汉式

​	https://img-blog.csdnimg.cn/20190623135131582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fic29sdXRlX2NoZW4=,size_16,color_FFFFFF,t_70

​	懒汉式，顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。有线程安全和线程不安全两种写法，区别就是synchronized关键字。

​	2.饿汉式

​	https://img-blog.csdnimg.cn/20190623135149892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fic29sdXRlX2NoZW4=,size_16,color_FFFFFF,t_70

​	饿汉式，从名字上也很好理解，就是“比较勤”，实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说。好处是没有线程安全的问题，坏处是浪费内存空间。

​	3.双重校验锁

​	https://img-blog.csdnimg.cn/20190623135205866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fic29sdXRlX2NoZW4=,size_16,color_FFFFFF,t_70

​	双检锁，又叫双重校验锁，综合了懒汉式和饿汉式两者的优缺点整合而成。看上面代码实现中，特点是在synchronized关键字内外都加了一层 if 条件判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。

​	4.静态类部类

​	https://img-blog.csdnimg.cn/20190623135218977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fic29sdXRlX2NoZW4=,size_16,color_FFFFFF,t_70

​	静态内部类的方式效果类似双检锁，但实现更简单。但这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。

​	5.枚举

​	https://img-blog.csdnimg.cn/20190623135234518.png

​	枚举的方式是比较少见的一种实现方式，但是看上面的代码实现，却更简洁清晰。并且她还自动支持序列化机制，绝对防止多次实例化。

---



**进程的状态**

创建

就绪：进程处于可运行的状态，只是CPU时间片还没有轮到该进程，则该进程处于就绪状态

运行：进程处于可运行的状态，且CPU时间片轮到该进程，则该进程处于运行状态

阻塞：进程不具备运行条件，并在等某个事件完成

终止

---



**线程池的四种拒绝策略**

①ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出RejectedExecutionException异常

②ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。

③ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务

④ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务

---



**interrupt线程中断的三种方式**

方法：

①isInterrupted():测试这个线程是否中断，实例方法

②interrupt（）：中断这个线程，实例方法

③interrupted(): 测试当前线程是否中断，静态方法

不是正实的中断，而是告诉某个线程，需要进行中断，具体是否需要中断，由线程自己决定

---



**线程安全的问题**

**1.原子性：**要执行全执行，要不执行全不执行

特殊原子性代码(分解执行存在编译为class文件时，也可能存在CPU执行指令)：

1. n++,n--,++n,--n都不是原子性：需要分解为三条指令：从内存读取变量到CPU，修改变量，写回内存
2. 对象的new操作，Object obj = new Object()：分解为三条指令：分配对象的内存，初始化对象，将对象赋值给变量

**2.可见性：**

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

**3.有序性：**

有序性：即程序执行的顺序按照代码的先后顺序执行。

在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性

----

**什么是死锁**

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。  因此我们举个例子来描述，如果此时有一个线程A，按照先锁a再获得锁b的的顺序获得锁，而在此同时又有另外一个线程B，按照先锁b再锁a的顺序获得锁。

https://img-blog.csdn.net/20180922173936964?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkMTIzNzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70

**产生死锁的原因**

a. 竞争资源

    系统中的资源可以分为两类：
    
    1.可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
    2.另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。
    
    产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
    产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁

b. 进程间推进顺序非法

    1.若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
    2.例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁
**产生死锁的4个必要条件**

1.互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2.请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3.不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4.环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

**预防死锁**

①资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
②只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
③可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
④资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

**避免死锁**

银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。

**解除死锁**

当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：

    剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；
    
    撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。

---



**方法重写和方法重载的区别**	  

| 方法重载               | 方法重写                                                     |
| ---------------------- | ------------------------------------------------------------ |
| overload               | override                                                     |
| 参数列表不同           | 参数列表必须完全相同                                         |
| 与返回值类型无关       | 返回值类型必须相同                                           |
| 可以有不同的访问修饰符 | 访问修饰符一定要大于等于被重写的方法的访问修饰符             |
| 可以抛出不同的异常     | 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常 |
| 编译时多态             | 运行时多态                                                   |

----



**内存泄漏和内存溢出**

内存溢出：(out of memory)是指程序载申请内存空间时，没有足够的内存空间供其使用，出现out of memory，比如：申请了一个Integer大小的内存空间，但给它存了long才能存下的数，就是内存溢出

内存泄漏：(memory leak)是指程序在申请内存后，无法释放已申请的内存空间。一次内存泄漏危害可以忽略，但内存泄漏堆积后果很严重，

大量的内存泄漏会导致内存溢出

---



**topk**

当数据量比较小的时候，可以采用全局排序，然后取前k大或者前k小。当数据量比较大的时候，采用分治法将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100*10000个数据里面找出最大的10000个。



全局排序  O(n*lg(n))：给所有的数都排序，然后取前K大或者前K小。

局部排序冒泡(n*k):首先第一种想法肯定是利用冒泡排序，求前K个数，只需要遍历K次即可。

堆排序(n*logk)：先构造一个大小为k的堆，求前k大的构建最小堆，（构建完之后，取新的元素，如果最小值小于当前的值，则覆盖然后调整一次堆）

快排(n*logn):首先选择一个标志位，如果这个标志位的序号index刚好是k，那么标志位和标志位左边的数，刚好就是top-k small data，如果index>k,那top-k small data在index的左边，那么就继续递归从index-1在数中选取top-k.如果index < k,那么说明还要从index的右边，选取top-(k-index) small data.

---



**说一说你认识的hashmap**

```
	*数组+链表/红黑树
   * 数组长度默认为16个大小
   * 加载因子默认是0.75
   * 在数组长度达到64同时链表长度大于等于8时将链表转换为红黑树
   * 扩容是元素大于等于数组长度*加载因子是扩容至大于他最近的2的n次方
   * 在jdk1.7是，头插
   * jdk1.8,尾插，解决了jdk1.7扩容时的多线程安全问题
   * jdk1.8时多线程问题体现在put操作
   * 一个key值的索引时利用：key的hascode的前16bit位和后16bit位**异或**再与数组长度-1相**与**
   * map接口的实现类，线程不安全，jdk1.7数组+链表，**键值对的存储方式，**继承Cloneable接口，能被克隆。
   * HashMap中key和value都允许为null。key为null的键值对永远都放在以table[0]为头结点的链表中。
```

---



**说一下tcp和udp的区别**

```
           	   TCP           UDP 
是否连接    	面向连接     面向非连接 
传输可靠性   	可靠        不可靠 
应用场合    	少量数据    传输大量数据
速度       		慢         快
```

---

**说说static关键字**

①static成员变量

​	Java中提供两种类型的变量：用static修饰的静态变量和不用static修饰的实例变量。静态变量属于类，在内存中只有一个复制，只要静态变量所在的类被加载，这个静态变量就会被分配空间，就可以使用了。对于静态变量的引用有两种方式：类.静态变量和对象.静态变量

​	实例变量属于对象，只有对象被创建后，实例变量才会被分配内存空间，才能被使用。它在内存中存在多个复制。只有用对象.实例对象引用  的方式来引用。

②static成员方法

​	Java中提供类static 方法和非static方法。static方法是类的方法，不需要创建对象就可以使用，而非static方法是对象方法，只有对象被创建出来才可以使用

​	static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和成员方法

③static代码块

​	static代码块在类中是独立于成员变量和成员函数的代码块的。注意：这些static代码块只会被执行一次

④static和finall结合使用表示的意思

​	对于变量，若使用static  finall修饰，表示一旦赋值不能修改，并且通过类名可以访问。

​	对于方法，若使用static  finall修饰，表示该方法不能被覆盖重写，并且可以通过类名直接访问

---

**java中成员变量，全局变量，局部变量的区别**

1.存储区域

全局变量：(全局静态变量)是放在方法区

成员变量：没有实例化的变量放在栈中，实例化了的对象放在堆中，栈中放的指向堆中的引用

局部变量：放在栈中，new的对象放在堆中，8中基本类型的变量放在栈中，变量所对应的值放在栈帧中

2.生命周期

全局变量：当类加载的时候被创建，在类中只有一份：会跟随类的消失而消失，生存时间长

成员变量：在对象被创建的时候而存在，当对象被GC回收的时候，它也会消失，生存时间一般

局部变量：在方法被调用的时候存在，当方法调用结束而消失，生存时间短。

3.作用域

全局变量：作用于整个类中，直接被类调用

成员变量：作用于整个类中（除静态方法不能使用，静态方法没有隐式的this），被对象调用

局部变量：作用在一个局部区域，比如一个方法中。

---



**谈一下Java中的异常**

异常的定义：阻止当前方法或作用域继续执行的问题。虽然Java中有处理异常的机制，但是要明确一点，异常可能会导致错误，之所以要有异常处理机制，就是为了提醒开发人员注意。

异常的处理方式：①使用try...catch...finally语句块处理

​								②在函数名后使用throws声明交给函数调用者caller去解决

检查型异常和非检查型异常：

​	是指**编译器**不会检查这类异常，不检查的则开发者在代码的编辑编译阶段就不是必须处理，这类异常一般可以避免，因此无需处理（try ...catch）。如果不处理这类异常，集成开发环境中的编译器也不会给出错误提示。

​	是指**编译器**要检查这类异常，检查的目的一方面是因为该类异常的发生难以避免，另一方面就是让开发者去解决掉这类异常，所以称为必须处理（try ...catch）的异常。如果不处理这类异常，集成开发环境中的编译器一般会给出错误提示。

​	Java中继承自java.lang.Exception类的异常都是检查型异常，所有继承自RuntimeExpection的异常称为非检查型异常。

----



**进程的状态及相互转换**

​	新建(New)   就绪(Runnable)   运行(Running)    阻塞(Blocked)   死亡(Dead)

​	就绪：进程处于可运行的状态，只是CPU时间片还没有轮转到该进程，则该进程处于就绪状态。

​	运行：进程处于可运行的状态，且CPU时间片轮转到该进程，该进程正在执行代码，则该进程处于运行状态。

​	阻塞：进程不具备运行条件，正在等待某个事件的完成

---

**线程的状态及相互转换**

初始状态：实现Runnable接口或者继承Thread类可以得到一个线程类，new一个实例出来，线程就进入初始状态

就绪状态：当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行

运行状态：如果处于就绪状态的线程获得了CPU时间片，开始执行run()方法的线程执行体，则该线程处于运行状态

阻塞状态：阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。

等待状态：处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。

超时等待：处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。

终止状态：当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。

几种方法的比较：

①Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态

②Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程

③thread.join()/thread.join(long millis)，当前线程里调用其它线程t的join方法，当前线程进入WAITING/TIMED_WAITING状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程一般情况下进入RUNNABLE状态，也有可能进入BLOCKED状态
④obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。

⑤obj.notify()/notifyAll唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。



**说说Java中的8大基本类型**

byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。

short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。

int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。

long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。

float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。

double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。

boolean：只有true和false两个取值。

char：16位，存储Unicode码，用单引号赋值。

**谈谈抽象类和接口**

- 1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。

- 2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。

- 3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。

- 4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

  **注**：JDK 1.8 以后，接口里可以有静态方法和方法体了。