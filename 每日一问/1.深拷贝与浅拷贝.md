**1.深拷贝与浅拷贝**

​	简单点来说，就是假设B复制了A，当修改A时，看B是否发生变化，如果B也跟着变了，就是浅拷贝。如果B没有变就是深拷贝。

a.基本类型--名值存储在栈内存中，例如let a=1;

https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124130901890-511917244.jpg

当你b=a复制时，栈内存会新开辟一个内存，例如这样：

https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124131822437-430949998.jpg

所以当你此时修改a=2，对b并不会造成影响，当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。

https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124133428359-1292133331.jpg

当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。

https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124133647796-1390255671.jpg

而当我们**a[0]=1**时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。

https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124133934328-67216865.jpg

那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，起步就达到深拷贝的效果了

https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124140906203-2099568933.jpg

————————————————————————————————————————————

**2.topk**

全局排序  O(n*lg(n))：给所有的数都排序，然后取前K大或者前K小。

局部排序冒泡(n*k):首先第一种想法肯定是利用冒泡排序，求前K个数，只需要遍历K次即可。

堆排序(n*logk)：先构造一个大小为k的堆，求前k大的构建最小堆，（构建完之后，取新的元素，如果最小值小于当前的值，则覆盖然后调整一次堆）

快排(n*logn):首先选择一个标志位，如果这个标志位的序号index刚好是k，那么标志位和标志位左边的数，刚好就是top-k small data，如果index>k,那top-k small data在index的左边，那么就继续递归从index-1在数中选取top-k.如果index < k,那么说明还要从index的右边，选取top-(k-index) small data.

----



**3.双亲委派机制**

![img](C:/Users/41709310114/AppData/Local/YNote/data/qqCD2F82A182BED18F31E40F8BAA4CF179/2cd1bbea47e94777bde417ea06e4b46b/clipboard.png

1、如果一个类加载器收到类加载请求，它不会自己先加载，而是委托给父类的加载器去执行

2、如果父类加载器还存在父类加载器，则进一步委托，直到到达最顶层的类加载器

3、如果父类加载器可以完成类的加载任务，就成功返回，如果不能完成再回退到子类加载器判断

**作用：**

**1、避免类的重复加载**

比如A、B类都需要加载 String 类，如果不用委托而是自己加载自己的，则会在内存中生成两份字节码。

**2、保护程序安全，防止程序员随意修改JDK的类。**

**3.类的加载过程：加载——>验证——>准备——>解析——>初始化**



----



**字节流和字符流的区别**

java流在处理上分为字符流和字节流，流中保存的实际上全都是字节文件 

①字符流（Writer/Reader）处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串。而字节流（OutputStream/InputStream）处理单元为1个字节，操作字节和字节数组。

②字节流可用于任何类型，而字符流只能处理字符或者字符串

③字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出。

​    字符流在操作的时候是使用到缓冲区的。如果字符流不调用close或flush方法，则不会输出任何内容。 

----



**hashcode和equals**

**HashMap**是基于散列函数，以数组和链表或者红黑树的方式实现的。

对于每一个对象，通过hashCode的方法可为气生成一个整形的值（散列码），改整形的值被处理后将作为数组的下标，存放该对象所对应的值。

equals()方法则是在HashMap中插入值或查询时会使用到，当HashMap中插入值或查询值对象的散列码与数组中对应的散列码相等时，则会通过equals方法比较key值是否相等，所以想以自建 对象作为HashMap的key，必须重写该对象继承的object、的equal、方法。

总结：

1.若重写了equals(Object obj)方法，则有必要重写hashCode()方法。

2.若两个对象equals(Object obj)返回true，则hashCode（）有必要也返回相同的int数。

3.若两个对象equals(Object obj)返回false，则hashCode（）不一定返回不同的int数。

4.若两个对象hashCode（）返回相同int数，则equals（Object obj）不一定返回true。

5.若两个对象hashCode（）返回不同int数，则equals（Object obj）一定返回false。

6.同一对象在执行期间若已经存储在集合中，则不能修改影响hashCode值的相关信息，否则会导致内存泄露问题。

----



**反射**

Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的方法和属性，对于任意一个对象，都能够调用它的任意的一个方法阿属性。这种动态获取的信息以及动态调用对象的方法称为反射。

----



**获取class的三种方式**

①对象 . getClass:getClass()方法在Object类中定义着

多用于对象获取字节码的方式

②类名 .class；通过类名的属性获取

多用于参数的传递

③Class . forName("全类名")：forName （String className）（常用）

多用于配置文件，将类名定义在配置文件中，读取文件，加载类

----



**反射优点和缺点**

优点：

①对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法

② 增加程序的灵活性和扩展性，降低耦合性，提高自适应能力

③反射已经运用在了很多流行框架如：Struts、Hibernate、Spring 等等。

缺点：

①我们认为反射是一个“自省”的过程，所以在性能上面有性能的问题，一般不建议用在小型程序上，可用到框架当中。

② 反射技术绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂 。

----



**事务**

https://blog.csdn.net/Stephen_curry_66/article/details/105987733

----



**索引**

https://blog.csdn.net/Stephen_curry_66/article/details/105967343

----



**session和cookie**

​	区别：1.cookie数据存放在客户浏览器上（客户端），session数据默认存放在服务器（服务端）的一个文件中（不是内存）

​				2.cookie不是很安全，别人可以分析存放在本地的cookie并进行欺骗，考虑安全的话使用session

​				3.session会在一定时间内保存在服务器上。当访问量增多时，会比较占用你服务器的性能，考虑到减轻服务器的性能，使用cookie

​				4.单个cookie保存的数据不能超过4k，很多浏览器限制一个站点最多保存20个cookie

​	联系：session的运行依赖session id，而session id 存放在cookie中，也就是说如果浏览器禁用了cookie，同时session同时也会失效（但是可以通过其他的方式实现，如在url中传递session id）。

​	应用场景：1.登录网站，今天输入用户名密码登录了，第二天再打开就直接可以打开了，这时候用到的就是cookie

​						2.session的一个场景是购物车，添加了商品之后客户端处知道添加了那些商品，而服务端如何判断呢，所以需要存储一些信息，就用到了session。

----



**AQS**

​	AbstractQueuedSychronizer(抽象的队列式同步器)

​	核心思想：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源 设定为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入队列中。

​	CLH队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。

​	功能：独占和共享

​		独占锁，每次只能有一个线程持有锁，比如ReentrantLock就是以独占方式实现的互斥锁

​		共享锁，允许多个线程同时获取锁，并发访问共享资源，比如ReentrantReadWriteLock

----



**公平锁和非公平锁**

​	公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能获得锁

​	优点：所有的线程都能得到资源不会饿死在队列中。

​	缺点：吞吐量会下降很多，队列里面除了第一个线程，其他线程都会阻塞，cpu唤醒阻塞线程的开销会很大

​	非公平锁：多个线程获取锁的时候，会直接获取，如果获取不到再次进入等待队列，如果获取的到就直接获取到锁。

​	优点：可以减少CPU唤醒线程的开销，整体的吞吐量会增加，CPU也不必唤醒所有的线程，会减少换取线程的数量

​	缺点：这样有可能导致有的线程一直获取不到锁，而出现饿死。

----



**JDBC**

​	①加载数据库驱动到JVM

​		class.forName("JDBC驱动类的名称");

​	②建立数据库连接

​		Connection conn=DriverManager.getConnection(数据库url，数据库名，密码);

​	③获取数据库操作对象

​		Statement stmt=conn.createStatement();

​	④定义操作的SQL语句

​		String sql="写sql语句";

​	⑤执行数据库操作

​		ResultSet rs=stmt.executeQuery(sql);

​	⑥获取并操作结果集

​		while(rs.next()){

​			System.out.println(rs.getInt("id"));

​			System.out.println(rs.getString("name"));

​		}

​	⑦关闭对象，回收数据库资源（关闭结果集——>关闭数据库操作对象——>关闭连接）

​		最后在finally中关闭对象，rs.close();

​													 stmt.close();

​													 conn.close();

----



**单例模式**

​	1.懒汉式

​	https://img-blog.csdnimg.cn/20190623135131582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fic29sdXRlX2NoZW4=,size_16,color_FFFFFF,t_70

​	懒汉式，顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。有线程安全和线程不安全两种写法，区别就是synchronized关键字。

​	2.饿汉式

​	https://img-blog.csdnimg.cn/20190623135149892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fic29sdXRlX2NoZW4=,size_16,color_FFFFFF,t_70

​	饿汉式，从名字上也很好理解，就是“比较勤”，实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说。好处是没有线程安全的问题，坏处是浪费内存空间。

​	3.双重校验锁

​	https://img-blog.csdnimg.cn/20190623135205866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fic29sdXRlX2NoZW4=,size_16,color_FFFFFF,t_70

​	双检锁，又叫双重校验锁，综合了懒汉式和饿汉式两者的优缺点整合而成。看上面代码实现中，特点是在synchronized关键字内外都加了一层 if 条件判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。

​	4.静态类部类

​	https://img-blog.csdnimg.cn/20190623135218977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fic29sdXRlX2NoZW4=,size_16,color_FFFFFF,t_70

​	静态内部类的方式效果类似双检锁，但实现更简单。但这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。

​	5.枚举

​	https://img-blog.csdnimg.cn/20190623135234518.png

​	枚举的方式是比较少见的一种实现方式，但是看上面的代码实现，却更简洁清晰。并且她还自动支持序列化机制，绝对防止多次实例化。

---



**进程的状态**

创建

就绪：进程处于可运行的状态，只是CPU时间片还没有轮到该进程，则该进程处于就绪状态

运行：进程处于可运行的状态，且CPU时间片轮到该进程，则该进程处于运行状态

阻塞：进程不具备运行条件，并在等某个事件完成

终止

---



**线程池的四种拒绝策略**

①ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出RejectedExecutionException异常

②ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。

③ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务

④ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务

---



**interrupt线程中断的三种方式**

方法：

①isInterrupted():测试这个线程是否中断，实例方法

②interrupt（）：中断这个线程，实例方法

③interrupted(): 测试当前线程是否中断，静态方法

不是正实的中断，而是告诉某个线程，需要进行中断，具体是否需要中断，由线程自己决定

---



**线程安全的问题**

**1.原子性：**要执行全执行，要不执行全不执行

特殊原子性代码(分解执行存在编译为class文件时，也可能存在CPU执行指令)：

1. n++,n--,++n,--n都不是原子性：需要分解为三条指令：从内存读取变量到CPU，修改变量，写回内存
2. 对象的new操作，Object obj = new Object()：分解为三条指令：分配对象的内存，初始化对象，将对象赋值给变量

**2.可见性：**

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

**3.有序性：**

有序性：即程序执行的顺序按照代码的先后顺序执行。

在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性

----

**什么是死锁**

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。  因此我们举个例子来描述，如果此时有一个线程A，按照先锁a再获得锁b的的顺序获得锁，而在此同时又有另外一个线程B，按照先锁b再锁a的顺序获得锁。

https://img-blog.csdn.net/20180922173936964?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkMTIzNzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70

**产生死锁的原因**

a. 竞争资源

    系统中的资源可以分为两类：
    
    1.可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
    2.另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。
    
    产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
    产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁

b. 进程间推进顺序非法

    1.若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
    2.例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁
**产生死锁的4个必要条件**

1.互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2.请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3.不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4.环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

**预防死锁**

①资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
②只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
③可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
④资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

**避免死锁**

银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。

**解除死锁**

当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：

    剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；
    
    撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。
